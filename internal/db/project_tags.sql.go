// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: project_tags.sql

package db

import (
	"context"
)

const addProjectTag = `-- name: AddProjectTag :exec
INSERT INTO project_tags (project_id, tag_id)
VALUES ($1, $2)
ON CONFLICT (project_id, tag_id) DO NOTHING
`

type AddProjectTagParams struct {
	ProjectID int64 `db:"project_id" json:"project_id"`
	TagID     int64 `db:"tag_id" json:"tag_id"`
}

func (q *Queries) AddProjectTag(ctx context.Context, arg AddProjectTagParams) error {
	_, err := q.db.Exec(ctx, addProjectTag, arg.ProjectID, arg.TagID)
	return err
}

const getProjectTags = `-- name: GetProjectTags :many
SELECT t.id, t.name, t.slug, t.is_deleted, t.created_at, t.deleted_at FROM tags t
INNER JOIN project_tags pt ON t.id = pt.tag_id
WHERE pt.project_id = $1 AND pt.is_deleted = false AND t.is_deleted = false
ORDER BY t.name
`

func (q *Queries) GetProjectTags(ctx context.Context, projectID int64) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getProjectTags, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByTag = `-- name: GetProjectsByTag :many
SELECT p.id, p.user_id, p.category_id, p.title, p.slug, p.short_description, p.full_description, p.cover_image, p.status, p.live_url, p.github_url, p.display_order, p.is_featured, p.image_count, p.tag_count, p.is_deleted, p.created_at, p.updated_at, p.deleted_at FROM projects p
INNER JOIN project_tags pt ON p.id = pt.project_id
WHERE pt.tag_id = $1 AND pt.is_deleted = false AND p.is_deleted = false
ORDER BY p.created_at DESC
`

func (q *Queries) GetProjectsByTag(ctx context.Context, tagID int64) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjectsByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.Slug,
			&i.ShortDescription,
			&i.FullDescription,
			&i.CoverImage,
			&i.Status,
			&i.LiveUrl,
			&i.GithubUrl,
			&i.DisplayOrder,
			&i.IsFeatured,
			&i.ImageCount,
			&i.TagCount,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeProjectTag = `-- name: RemoveProjectTag :exec
UPDATE project_tags
SET is_deleted = true
WHERE project_id = $1 AND tag_id = $2
`

type RemoveProjectTagParams struct {
	ProjectID int64 `db:"project_id" json:"project_id"`
	TagID     int64 `db:"tag_id" json:"tag_id"`
}

func (q *Queries) RemoveProjectTag(ctx context.Context, arg RemoveProjectTagParams) error {
	_, err := q.db.Exec(ctx, removeProjectTag, arg.ProjectID, arg.TagID)
	return err
}
