// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package db

import (
	"context"
)

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
  user_id,
  category_id,
  title,
  slug,
  short_description,
  full_description,
  cover_image,
  status,
  live_url,
  github_url,
  display_order,
  is_featured
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
RETURNING id, user_id, category_id, title, slug, short_description, full_description, cover_image, status, live_url, github_url, display_order, is_featured, image_count, tag_count, is_deleted, created_at, updated_at, deleted_at
`

type CreateProjectParams struct {
	UserID           int64   `db:"user_id" json:"user_id"`
	CategoryID       *int64  `db:"category_id" json:"category_id"`
	Title            string  `db:"title" json:"title"`
	Slug             string  `db:"slug" json:"slug"`
	ShortDescription *string `db:"short_description" json:"short_description"`
	FullDescription  *string `db:"full_description" json:"full_description"`
	CoverImage       *string `db:"cover_image" json:"cover_image"`
	Status           string  `db:"status" json:"status"`
	LiveUrl          *string `db:"live_url" json:"live_url"`
	GithubUrl        *string `db:"github_url" json:"github_url"`
	DisplayOrder     int32   `db:"display_order" json:"display_order"`
	IsFeatured       bool    `db:"is_featured" json:"is_featured"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.UserID,
		arg.CategoryID,
		arg.Title,
		arg.Slug,
		arg.ShortDescription,
		arg.FullDescription,
		arg.CoverImage,
		arg.Status,
		arg.LiveUrl,
		arg.GithubUrl,
		arg.DisplayOrder,
		arg.IsFeatured,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.Slug,
		&i.ShortDescription,
		&i.FullDescription,
		&i.CoverImage,
		&i.Status,
		&i.LiveUrl,
		&i.GithubUrl,
		&i.DisplayOrder,
		&i.IsFeatured,
		&i.ImageCount,
		&i.TagCount,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const decrementProjectImageCount = `-- name: DecrementProjectImageCount :exec
UPDATE projects
SET image_count = GREATEST(image_count - 1, 0)
WHERE id = $1
`

func (q *Queries) DecrementProjectImageCount(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, decrementProjectImageCount, id)
	return err
}

const decrementProjectTagCount = `-- name: DecrementProjectTagCount :exec
UPDATE projects
SET tag_count = GREATEST(tag_count - 1, 0)
WHERE id = $1
`

func (q *Queries) DecrementProjectTagCount(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, decrementProjectTagCount, id)
	return err
}

const getProjectByID = `-- name: GetProjectByID :one

SELECT id, user_id, category_id, title, slug, short_description, full_description, cover_image, status, live_url, github_url, display_order, is_featured, image_count, tag_count, is_deleted, created_at, updated_at, deleted_at FROM projects
WHERE id = $1 AND is_deleted = false
LIMIT 1
`

// ===========================================
// sql/queries/projects.sql
// ===========================================
func (q *Queries) GetProjectByID(ctx context.Context, id int64) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.Slug,
		&i.ShortDescription,
		&i.FullDescription,
		&i.CoverImage,
		&i.Status,
		&i.LiveUrl,
		&i.GithubUrl,
		&i.DisplayOrder,
		&i.IsFeatured,
		&i.ImageCount,
		&i.TagCount,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProjectBySlug = `-- name: GetProjectBySlug :one
SELECT id, user_id, category_id, title, slug, short_description, full_description, cover_image, status, live_url, github_url, display_order, is_featured, image_count, tag_count, is_deleted, created_at, updated_at, deleted_at FROM projects
WHERE slug = $1 AND user_id = $2 AND is_deleted = false
LIMIT 1
`

type GetProjectBySlugParams struct {
	Slug   string `db:"slug" json:"slug"`
	UserID int64  `db:"user_id" json:"user_id"`
}

func (q *Queries) GetProjectBySlug(ctx context.Context, arg GetProjectBySlugParams) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectBySlug, arg.Slug, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.Slug,
		&i.ShortDescription,
		&i.FullDescription,
		&i.CoverImage,
		&i.Status,
		&i.LiveUrl,
		&i.GithubUrl,
		&i.DisplayOrder,
		&i.IsFeatured,
		&i.ImageCount,
		&i.TagCount,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const incrementProjectImageCount = `-- name: IncrementProjectImageCount :exec
UPDATE projects
SET image_count = image_count + 1
WHERE id = $1
`

func (q *Queries) IncrementProjectImageCount(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, incrementProjectImageCount, id)
	return err
}

const incrementProjectTagCount = `-- name: IncrementProjectTagCount :exec
UPDATE projects
SET tag_count = tag_count + 1
WHERE id = $1
`

func (q *Queries) IncrementProjectTagCount(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, incrementProjectTagCount, id)
	return err
}

const listFeaturedProjects = `-- name: ListFeaturedProjects :many
SELECT id, user_id, category_id, title, slug, short_description, full_description, cover_image, status, live_url, github_url, display_order, is_featured, image_count, tag_count, is_deleted, created_at, updated_at, deleted_at FROM projects
WHERE user_id = $1 AND is_featured = true AND is_deleted = false
ORDER BY display_order ASC
LIMIT $2
`

type ListFeaturedProjectsParams struct {
	UserID int64 `db:"user_id" json:"user_id"`
	Limit  int32 `db:"limit" json:"limit"`
}

func (q *Queries) ListFeaturedProjects(ctx context.Context, arg ListFeaturedProjectsParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, listFeaturedProjects, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.Slug,
			&i.ShortDescription,
			&i.FullDescription,
			&i.CoverImage,
			&i.Status,
			&i.LiveUrl,
			&i.GithubUrl,
			&i.DisplayOrder,
			&i.IsFeatured,
			&i.ImageCount,
			&i.TagCount,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsByStatus = `-- name: ListProjectsByStatus :many
SELECT id, user_id, category_id, title, slug, short_description, full_description, cover_image, status, live_url, github_url, display_order, is_featured, image_count, tag_count, is_deleted, created_at, updated_at, deleted_at FROM projects
WHERE user_id = $1 AND status = $2 AND is_deleted = false
ORDER BY created_at DESC
`

type ListProjectsByStatusParams struct {
	UserID int64  `db:"user_id" json:"user_id"`
	Status string `db:"status" json:"status"`
}

func (q *Queries) ListProjectsByStatus(ctx context.Context, arg ListProjectsByStatusParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, listProjectsByStatus, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.Slug,
			&i.ShortDescription,
			&i.FullDescription,
			&i.CoverImage,
			&i.Status,
			&i.LiveUrl,
			&i.GithubUrl,
			&i.DisplayOrder,
			&i.IsFeatured,
			&i.ImageCount,
			&i.TagCount,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserProjects = `-- name: ListUserProjects :many
SELECT id, user_id, category_id, title, slug, short_description, full_description, cover_image, status, live_url, github_url, display_order, is_featured, image_count, tag_count, is_deleted, created_at, updated_at, deleted_at FROM projects
WHERE user_id = $1 AND is_deleted = false
ORDER BY display_order ASC, created_at DESC
`

func (q *Queries) ListUserProjects(ctx context.Context, userID int64) ([]Project, error) {
	rows, err := q.db.Query(ctx, listUserProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Title,
			&i.Slug,
			&i.ShortDescription,
			&i.FullDescription,
			&i.CoverImage,
			&i.Status,
			&i.LiveUrl,
			&i.GithubUrl,
			&i.DisplayOrder,
			&i.IsFeatured,
			&i.ImageCount,
			&i.TagCount,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProject = `-- name: SoftDeleteProject :exec
UPDATE projects
SET is_deleted = true
WHERE id = $1
`

func (q *Queries) SoftDeleteProject(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, softDeleteProject, id)
	return err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET 
  category_id = COALESCE($1, category_id),
  title = COALESCE($2, title),
  slug = COALESCE($3, slug),
  short_description = COALESCE($4, short_description),
  full_description = COALESCE($5, full_description),
  cover_image = COALESCE($6, cover_image),
  status = COALESCE($7, status),
  live_url = COALESCE($8, live_url),
  github_url = COALESCE($9, github_url),
  display_order = COALESCE($10, display_order),
  is_featured = COALESCE($11, is_featured)
WHERE id = $12 AND is_deleted = false
RETURNING id, user_id, category_id, title, slug, short_description, full_description, cover_image, status, live_url, github_url, display_order, is_featured, image_count, tag_count, is_deleted, created_at, updated_at, deleted_at
`

type UpdateProjectParams struct {
	CategoryID       *int64            `db:"category_id" json:"category_id"`
	Title            *string           `db:"title" json:"title"`
	Slug             *string           `db:"slug" json:"slug"`
	ShortDescription *string           `db:"short_description" json:"short_description"`
	FullDescription  *string           `db:"full_description" json:"full_description"`
	CoverImage       *string           `db:"cover_image" json:"cover_image"`
	Status           NullContentStatus `db:"status" json:"status"`
	LiveUrl          *string           `db:"live_url" json:"live_url"`
	GithubUrl        *string           `db:"github_url" json:"github_url"`
	DisplayOrder     *int32            `db:"display_order" json:"display_order"`
	IsFeatured       *bool             `db:"is_featured" json:"is_featured"`
	ID               int64             `db:"id" json:"id"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject,
		arg.CategoryID,
		arg.Title,
		arg.Slug,
		arg.ShortDescription,
		arg.FullDescription,
		arg.CoverImage,
		arg.Status,
		arg.LiveUrl,
		arg.GithubUrl,
		arg.DisplayOrder,
		arg.IsFeatured,
		arg.ID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CategoryID,
		&i.Title,
		&i.Slug,
		&i.ShortDescription,
		&i.FullDescription,
		&i.CoverImage,
		&i.Status,
		&i.LiveUrl,
		&i.GithubUrl,
		&i.DisplayOrder,
		&i.IsFeatured,
		&i.ImageCount,
		&i.TagCount,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
