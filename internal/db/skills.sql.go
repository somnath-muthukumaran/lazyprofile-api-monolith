// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: skills.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSkill = `-- name: CreateSkill :one
INSERT INTO skills (
  user_id,
  category_id,
  name,
  proficiency,
  icon,
  status,
  display_order
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, user_id, category_id, name, proficiency, icon, status, display_order, usage_count, is_deleted, created_at, updated_at, deleted_at
`

type CreateSkillParams struct {
	UserID       int64   `db:"user_id" json:"user_id"`
	CategoryID   *int64  `db:"category_id" json:"category_id"`
	Name         string  `db:"name" json:"name"`
	Proficiency  *int32  `db:"proficiency" json:"proficiency"`
	Icon         *string `db:"icon" json:"icon"`
	Status       string  `db:"status" json:"status"`
	DisplayOrder int32   `db:"display_order" json:"display_order"`
}

func (q *Queries) CreateSkill(ctx context.Context, arg CreateSkillParams) (Skill, error) {
	row := q.db.QueryRow(ctx, createSkill,
		arg.UserID,
		arg.CategoryID,
		arg.Name,
		arg.Proficiency,
		arg.Icon,
		arg.Status,
		arg.DisplayOrder,
	)
	var i Skill
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CategoryID,
		&i.Name,
		&i.Proficiency,
		&i.Icon,
		&i.Status,
		&i.DisplayOrder,
		&i.UsageCount,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const decrementSkillUsage = `-- name: DecrementSkillUsage :exec
UPDATE skills
SET usage_count = GREATEST(usage_count - 1, 0)
WHERE id = $1
`

func (q *Queries) DecrementSkillUsage(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, decrementSkillUsage, id)
	return err
}

const getSkillByID = `-- name: GetSkillByID :one
SELECT id, user_id, category_id, name, proficiency, icon, status, display_order, usage_count, is_deleted, created_at, updated_at, deleted_at FROM skills
WHERE id = $1 AND is_deleted = false
LIMIT 1
`

func (q *Queries) GetSkillByID(ctx context.Context, id int64) (Skill, error) {
	row := q.db.QueryRow(ctx, getSkillByID, id)
	var i Skill
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CategoryID,
		&i.Name,
		&i.Proficiency,
		&i.Icon,
		&i.Status,
		&i.DisplayOrder,
		&i.UsageCount,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const incrementSkillUsage = `-- name: IncrementSkillUsage :exec
UPDATE skills
SET usage_count = usage_count + 1
WHERE id = $1
`

func (q *Queries) IncrementSkillUsage(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, incrementSkillUsage, id)
	return err
}

const listTopSkills = `-- name: ListTopSkills :many
SELECT id, user_id, category_id, name, proficiency, icon, status, display_order, usage_count, is_deleted, created_at, updated_at, deleted_at FROM skills
WHERE user_id = $1 AND is_deleted = false
ORDER BY usage_count DESC, proficiency DESC
LIMIT $2
`

type ListTopSkillsParams struct {
	UserID int64 `db:"user_id" json:"user_id"`
	Limit  int32 `db:"limit" json:"limit"`
}

func (q *Queries) ListTopSkills(ctx context.Context, arg ListTopSkillsParams) ([]Skill, error) {
	rows, err := q.db.Query(ctx, listTopSkills, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Skill{}
	for rows.Next() {
		var i Skill
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Name,
			&i.Proficiency,
			&i.Icon,
			&i.Status,
			&i.DisplayOrder,
			&i.UsageCount,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSkills = `-- name: ListUserSkills :many
SELECT s.id, s.user_id, s.category_id, s.name, s.proficiency, s.icon, s.status, s.display_order, s.usage_count, s.is_deleted, s.created_at, s.updated_at, s.deleted_at, sc.name as category_name
FROM skills s
LEFT JOIN skill_categories sc ON s.category_id = sc.id
WHERE s.user_id = $1 AND s.is_deleted = false
ORDER BY sc.display_order, s.display_order
`

type ListUserSkillsRow struct {
	ID           int64              `db:"id" json:"id"`
	UserID       int64              `db:"user_id" json:"user_id"`
	CategoryID   *int64             `db:"category_id" json:"category_id"`
	Name         string             `db:"name" json:"name"`
	Proficiency  *int32             `db:"proficiency" json:"proficiency"`
	Icon         *string            `db:"icon" json:"icon"`
	Status       string             `db:"status" json:"status"`
	DisplayOrder int32              `db:"display_order" json:"display_order"`
	UsageCount   int32              `db:"usage_count" json:"usage_count"`
	IsDeleted    bool               `db:"is_deleted" json:"is_deleted"`
	CreatedAt    time.Time          `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	DeletedAt    pgtype.Timestamptz `db:"deleted_at" json:"deleted_at"`
	CategoryName *string            `db:"category_name" json:"category_name"`
}

func (q *Queries) ListUserSkills(ctx context.Context, userID int64) ([]ListUserSkillsRow, error) {
	rows, err := q.db.Query(ctx, listUserSkills, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserSkillsRow{}
	for rows.Next() {
		var i ListUserSkillsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Name,
			&i.Proficiency,
			&i.Icon,
			&i.Status,
			&i.DisplayOrder,
			&i.UsageCount,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSkillsByCategory = `-- name: ListUserSkillsByCategory :many
SELECT id, user_id, category_id, name, proficiency, icon, status, display_order, usage_count, is_deleted, created_at, updated_at, deleted_at FROM skills
WHERE user_id = $1 AND category_id = $2 AND is_deleted = false
ORDER BY display_order ASC
`

type ListUserSkillsByCategoryParams struct {
	UserID     int64  `db:"user_id" json:"user_id"`
	CategoryID *int64 `db:"category_id" json:"category_id"`
}

func (q *Queries) ListUserSkillsByCategory(ctx context.Context, arg ListUserSkillsByCategoryParams) ([]Skill, error) {
	rows, err := q.db.Query(ctx, listUserSkillsByCategory, arg.UserID, arg.CategoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Skill{}
	for rows.Next() {
		var i Skill
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CategoryID,
			&i.Name,
			&i.Proficiency,
			&i.Icon,
			&i.Status,
			&i.DisplayOrder,
			&i.UsageCount,
			&i.IsDeleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteSkill = `-- name: SoftDeleteSkill :exec
UPDATE skills
SET is_deleted = true
WHERE id = $1
`

func (q *Queries) SoftDeleteSkill(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, softDeleteSkill, id)
	return err
}

const updateSkill = `-- name: UpdateSkill :one
UPDATE skills
SET 
  category_id = COALESCE($1, category_id),
  name = COALESCE($2, name),
  proficiency = COALESCE($3, proficiency),
  icon = COALESCE($4, icon),
  status = COALESCE($5, status),
  display_order = COALESCE($6, display_order)
WHERE id = $7 AND is_deleted = false
RETURNING id, user_id, category_id, name, proficiency, icon, status, display_order, usage_count, is_deleted, created_at, updated_at, deleted_at
`

type UpdateSkillParams struct {
	CategoryID   *int64            `db:"category_id" json:"category_id"`
	Name         *string           `db:"name" json:"name"`
	Proficiency  *int32            `db:"proficiency" json:"proficiency"`
	Icon         *string           `db:"icon" json:"icon"`
	Status       NullContentStatus `db:"status" json:"status"`
	DisplayOrder *int32            `db:"display_order" json:"display_order"`
	ID           int64             `db:"id" json:"id"`
}

func (q *Queries) UpdateSkill(ctx context.Context, arg UpdateSkillParams) (Skill, error) {
	row := q.db.QueryRow(ctx, updateSkill,
		arg.CategoryID,
		arg.Name,
		arg.Proficiency,
		arg.Icon,
		arg.Status,
		arg.DisplayOrder,
		arg.ID,
	)
	var i Skill
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CategoryID,
		&i.Name,
		&i.Proficiency,
		&i.Icon,
		&i.Status,
		&i.DisplayOrder,
		&i.UsageCount,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
